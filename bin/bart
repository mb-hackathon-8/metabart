#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from re import search, compile, sub
from collections import defaultdict
from argparse import ArgumentParser, SUPPRESS
import os
from difflib import SequenceMatcher
from subprocess import Popen, PIPE
from pathlib import Path
from time import time
import logging
from sys import version_info, platform
from bart.version import __version__
from bart.kma import ipe
from bart.ascii import bart_ascii

__author__ = "Tom Stanton"
__license__ = "MIT"
__maintainer__ = "Tom Stanton"
__email__ = "tomdstanton@gmail.com"
__status__ = "Development"

def parse_args():
    parser = ArgumentParser(add_help=False, usage="bart input.fq.gz [options] > outfile.tab")
    parser.add_argument('input', nargs='+', type=Path, help=SUPPRESS)
    parser.print_usage = parser.print_help
    options = parser.add_argument_group('--options [defaults]')
    options.add_argument('-s', metavar='scheme', nargs='?', type=str, const='', help='''force scheme, see bart-update -s''')
    options.add_argument('-p', type=int, metavar='[95]', default=95, help='''template percent cutoff''')
    options.add_argument('-o', metavar='input path', nargs='?', type=str, const='', help='''export alleles to fasta''')
    options.add_argument('-k', action='store_true', default=False, help='''keep temporary files''')
    options.add_argument('-l', metavar='cwd', nargs='?', type=str, const='', help='''create logfile''')
    options.add_argument('-t', type=int, default=4, metavar='[4]', help='''threads''')
    options.add_argument('-q', action='store_true', default=False, help='''silence messages''')
    options.add_argument('-h', action='help', help='show this help message and exit')
    args = parser.parse_args()
    return args


def main():
    bin_path = os.path.join(os.path.dirname(os.path.dirname(__file__)))
    os.makedirs(f'{bin_path}/db/indexes', exist_ok=True)
    os.makedirs(f'{bin_path}/db/mapping', exist_ok=True)
    #db_path = f'{bin_path}/db'
    db_path = '/home/tom/PycharmProjects/bart/db'
    logger = logging.getLogger('root')
    logging.basicConfig(format='%(asctime)s | %(message)s', datefmt="%H:%M:%S")
    logger.setLevel(logging.DEBUG)
    args = parse_args()
    if args.q:
        logger.setLevel(logging.ERROR)
    if args.l is not None:
        logpath = args.l
        if logpath == '':
            logpath = f'{os.getcwd()}/bart_{str(time()).split(".")[0]}.log'
        logger.addHandler(logging.FileHandler(logpath))
    logger.info(f'this is bart {__version__} by {__author__}')
    logger.info(f'running on {platform} with Python {str(version_info[:3])[1:-1].replace(", ", ".")}')

##### Check input #####
    threads = str(args.t)
    if args.t > os.cpu_count():
        logger.warning(f'number of threads exceeds available CPUs')
        threads = str(os.cpu_count())
    logger.info(f'using {threads} threads')

    suffixes = ['_R[12]\.(fastq(?:\.gz)?)$', '_R[12]_[0-9]+?\.(fastq(?:\.gz)?)$',
                '_R[12].[0-9]+?\.(fastq(?:\.gz)?)$', '_[12]\.(fastq(?:\.gz)?)$',
                '_[12]_[0-9]+?\.(fastq(?:\.gz)?)$', '_[12].[0-9]+?\.(fastq(?:\.gz)?)$',
                '_R[12]\.(fq(?:\.gz)?)$', '_R[12]_[0-9]+?\.(fq(?:\.gz)?)$',
                '_R[12].[0-9]+?\.(fq(?:\.gz)?)$', '_[12]\.(fq(?:\.gz)?)$',
                '_[12]_[0-9]+?\.(fq(?:\.gz)?)$', '_[12].[0-9]+?\.(fq(?:\.gz)?)$']

    r = compile('|'.join(suffixes))
    pairs = defaultdict(list)
    for i in args.input:
        if not os.path.isfile(i):
            logger.error(f'{i} is not a valid file')
        else:
            filename = str(i)
            s = search(r, filename)
            if s:
                pairs[filename.replace(s.group(0), '')].append(str(i))
            else:
                logger.error(f'{i} is not a fastq file')

    if not any(os.scandir(f'{db_path}/indexes')):
        logger.info("no indexes found, building from PubMLST")
        os.system("bart-update -p")

    start = time()

##### Loop over read-pair dict #####
    for reads in list(pairs):
        sample = os.path.basename(reads)
        if len(pairs[reads]) != 2:
            logger.error(f'no read pair found for {sample}: {" ".join(pairs[reads])}')
            continue
        logger.info(f'read pair for {sample}: {" ".join(pairs[reads])}')

        if args.s is not None:
            if not args.s in [f.name.split('.')[0] for f in os.scandir(f'{db_path}/mapping/')]:
                exit(logger.error(f'{args.s} not a valid scheme, use bart-update -s to see valid schemes'))
            else:
                scheme = args.s

##### Choose Scheme #####
        else:
            cmd = ['refseq_masher', 'matches', pairs[reads][0]]
            logger.info(f'{" ".join(cmd)}')
            child = Popen(cmd, stdout=PIPE, stderr=PIPE).communicate()
            for line in child[1].decode('utf-8').splitlines():
                logger.info(line.lower())
            mash_out = sub(r'\W+', '', child[0].decode('utf-8').splitlines()[1].split('\t')[1])
            logger.info(f'closest refseq genome is {mash_out}')
            genus, species = mash_out.split(' ')[0], mash_out.split(' ')[1]
            schemes = [f.name.split('.')[0] for f in os.scandir(f'{db_path}/mapping/')]
            scheme = ''

            # FIRST SOME LOGIC
            if 'Shigella' in mash_out or 'Escherichia coli' in mash_out:
                scheme = 'Escherichia_coli#1'
                logger.warning(f'defaulting to {scheme}, use --scheme to override this behavior')
            elif 'baumannii' in mash_out:
                scheme = 'Acinetobacter_baumannii#2'
                logger.warning(f'defaulting to {scheme}, use --scheme to override this behavior')
            else:
                genus_list = [s for s in schemes if genus in s]

                if not genus_list: # critical if no matching genus, exit program here and prompt to force scheme
                    logger.error(f"no matching schemes for {genus}"
                                 f", check available schemes with bart-update -s")
                    continue

                elif len(genus_list) == 1:
                    logger.info(f"genus match for scheme {genus_list[0]}")
                    scheme = genus_list[0]

                else: # check species now
                    logger.info(f"{len(genus_list)} matching schemes for {genus}")
                    species_list = list(set([g.split('_', 1)[1] for g in genus_list]))
                    for s in species_list:
                        if species in s:
                            scheme = f'{genus}_{s}'
                            logger.info(f"matched {species} to {scheme}")
                            break

                    if not scheme:  # check to see if species is included in any schemes for genus
                        logger.warning(f'no matching schemes for {species}')
                        for i in genus_list:
                            with open(f'{db_path}/mapping/{i}.tab') as f:
                                if species in f.read():
                                    scheme = i
                                    logger.info(f'{scheme} covers {species}')
                                    break

                    if not scheme:  # check spp or complex schemes
                        for s in species_list:
                            if 'spp' in s or 'complex' in s:
                                scheme = f'{genus}_{s}'
                                logger.info(f"{scheme} might cover your species")
                                break

                    if not scheme: # finally give up
                        logger.error("check available schemes with bart-update -s")
                        continue

##### Run mapping and parse results #####
        ipe(pairs[reads], f'/tmp/{sample}', str(args.p), f'{db_path}/indexes/{scheme}', threads)
        with open(f'/tmp/{sample}.res', newline='\n') as res:
        #with open('/tmp/1483797.res', newline='\n') as res:
            r = res.read().splitlines()
        res_dict, sub_dict = {}, {} # make a dictionary of kma results where allele is the key
        for line in r[1:]:
            v = [x.strip(' ') for x in line.split('\t')]
            k = v[0].rsplit('_', 1)[0]
            v[0] = v[0].rsplit('_', 1)[1]
            if k in list(res_dict):
                if float(v[4]) > float(res_dict[k][4]): # if 2 alleles, choose highest percid [4], [2] might be better
                    sub_dict[k] = res_dict[k]
                    res_dict[k] = v
                else:
                    sub_dict[k] = v
            else:
                res_dict[k] = v

        if len(res_dict) > 0:
            logger.info(f'{len(res_dict)} hits found')
        else:
            logger.error('no hits found')
            continue

##### Assign profile via a range of methods #####
        with open(f'{db_path}/mapping/{scheme}.tab', newline='\n') as tab:
        #with open('/home/tom/PycharmProjects/bart/db/mapping/Citrobacter_freundii.tab', newline='\n') as tab:
            s = tab.read().splitlines()
        headers, scheme_dict = s[0].split('\t')[1:], {}  # make a dictionary of the scheme where ST is the key
        for line in s[1:]: # first column is ST
            v = line.split('\t')
            scheme_dict[int(v[0])] = {headers[i]: v[1:][i] for i in range(len(headers))}

        # make a list of only genes in headers
        genes, exact, no_hit = [g for g in headers if g not in ['clonal_complex', 'species', 'CC', 'Lineage']], [], []
        for x, i in enumerate(headers):  # add info in output header for non-exact matches
            if i in genes:
                if i in res_dict.keys():
                    if float(res_dict[i][4]) < 100 and float(res_dict[i][5]) < 100:
                        headers[x] = f'{i}!'
                    elif float(res_dict[i][4]) < 100:
                        headers[x] = f'{i}*'
                    elif float(res_dict[i][5]) < 100:
                        headers[x] = f'{i}~'
                    else:
                        exact.append(i) # make a list of genes with exact matches
                else:
                    no_hit.append(i)
                    headers[x] = f'{i}#'
                    logger.info('no hit for ' + i)
                    for p in scheme_dict.keys():
                        if scheme_dict[p][i] == '0':
                            logger.info(f'this scheme considers missing {i} alleles, setting {i} allele to 0')
                            res_dict[i] = ['0'] + ['missing'] * 10
                            exact.append(i)
                            break

        # remove no-hits if scheme doesn't consider 0 as allele
        [genes.remove(gene) for gene in no_hit if gene not in exact]
        not_exact = list({*exact} ^ {*res_dict.keys()}) # make a list of non-exact genes

        # Quickly filter profiles based on exact hits #
        profile_dict = dict(scheme_dict)
        for i in exact:
            for st in list(profile_dict.keys()):
                if scheme_dict[st][i] != res_dict[i][0]:
                    profile_dict.pop(st)

        # Use LCS to find closest profiles #
        if len(profile_dict) != 1:
            logger.info(f'{len(profile_dict)} exact profile matches, finding closest')
            profile_dict = {}
            def profile_LCS(in_dict):
                r, t = 0.1, [] # set ratio to 0.1 to filter low hits
                profile = [in_dict[gene][0] for gene in genes]
                for st in scheme_dict.keys():
                    seqs = [scheme_dict[st][gene] for gene in genes], [scheme_dict[st][gene] for gene in exact]
                    for seq in seqs: # gene and exact matching can give different results, so run both
                        s = SequenceMatcher(None, profile, seq).ratio()
                        if s > r:
                            r = s # this is a problem because the first ST will always be appended
                            t.append(st)
                t = [i for i in t if i != 1] # remove result for ST1, assumes first ST in scheme is always 1
                # repeat for first ST
                seqs = [scheme_dict[1][gene] for gene in genes], [scheme_dict[1][gene] for gene in exact]
                for seq in seqs:
                    s = SequenceMatcher(None, seq, profile).ratio()
                    if s > r:
                        r = s
                        t.append(1)
                return r, t

            ratio, topst = profile_LCS(res_dict)

            if len(sub_dict) > 0: # see sub-hits match profiles better
                for gene in sub_dict.keys():
                    tmp_dict = dict(res_dict)
                    tmp_dict[gene] = sub_dict[gene]
                    r_sub, t_sub = profile_LCS(tmp_dict)
                    if r_sub > ratio:
                        logger.info(f'sub-hit {gene}_{sub_dict[gene][0]} matches '
                                    f'{len(t_sub)} profiles at {int(r_sub * 100)}% '
                                    f'compared to {int(ratio * 100)}% for {gene}_{res_dict[gene][0]}')
                        ratio, res_dict[gene] = r_sub, sub_dict[gene]
                        topst += t_sub

            if len(topst) > len(set(topst)): # choose most likely STs from gene and exact matching, will appear twice
                for st in set(topst): # make top sts unique and iterate
                    if topst.count(st) == 2: # max value is 2
                        profile_dict[st] = scheme_dict[st]
            else:
                for st in topst:
                    profile_dict[st] = scheme_dict[st]

            if len(profile_dict) != 0:
                logger.info(f'displaying {len(profile_dict)} profile(s) with {int(ratio * 100)}% match')
            else:
                logger.warning(f'no profile matches')

##### Printing output #####
        print('Sample\tScheme\tST\t' + "\t".join([str(x) for x in headers]))
        if len(profile_dict) == 0:
            out = sample + '\t' + scheme + '\t' + '?'
            for gene in res_dict.keys():
                out += '\t' + res_dict[gene][0]
            print(out)
        else: # just print results if no profile match
            for st in profile_dict.keys():
                out = sample + '\t' + scheme + '\t' + str(st)
                for k, v in profile_dict[st].items():
                    if k in [s.strip('~').strip('!').strip('*') for s in headers]:
                        if v != '':
                            out += '\t' + v
                    else:
                        out += '\t-'
                print(out)

        if args.o is not None:
            outfile = args.o
            if outfile == '':
                delim = '.'
                if '_' in pairs[reads][0]:
                    delim = '_'
                outfile = f'{pairs[reads][0].split(delim, 1)[0]}_alleles.fna'
            with open(f'/tmp/{sample}.fsa', newline='\n') as fna, open(outfile, 'wt') as out:
                for seq in fna.read().split('>')[1:]:
                    for k, v in res_dict.items():
                        if f'{k}_{v[0]}' in seq:
                            if k in not_exact:
                                out.write('>{}_novel\n{}'.format(k, seq.split("\n", 1)[1]))
                            else:
                                out.write('>{}_{}\n{}'.format(k, v[0], seq.split("\n", 1)[1]))
            logger.info(f'written alleles to {outfile}')

##### Cleanup #####
        if not args.k:
            logger.info(f'cleaning up files in /tmp/')
            for f in os.listdir('/tmp/'):
                if sample in f:
                    os.remove(f'/tmp/{f}')
        else:
            logger.info(f'kept files in /tmp/')

    logger.info(f'completed in {"{:.1f}".format(time() - start)} seconds{bart_ascii()}')


if __name__ == '__main__':
    main()
