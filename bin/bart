#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from re import search, compile
from collections import defaultdict
from argparse import ArgumentParser
import os
from pathlib import Path
from time import time
import logging
from difflib import SequenceMatcher
from sys import version_info, platform
import bart
from bart.version import __version__
from bart.kma import ipe
from bart import finch
from bart.ascii import bart_ascii

__author__ = "Tom Stanton"
__license__ = "MIT"
__maintainer__ = "Tom Stanton"
__email__ = "tomdstanton@gmail.com"
__status__ = "Development"

def parse_args():
    parser = ArgumentParser(add_help=False, usage="bart *.fq.gz [options]")
    parser.add_argument('i', nargs='+', type=Path, help='Paired-end fastq(.gz)')
    parser.add_argument('-e', action='store_true', default=False, help='export alleles to fasta')
    parser.add_argument('--percid', type=int, default=95, help='percid')
    parser.add_argument('--info', action='store_true', default=False, help='get genome info')
    parser.add_argument('--use-scheme', metavar='scheme', nargs='?', type=str, const='', help='force scheme')
    parser.add_argument('-t', type=int, default=4, help='threads')
    parser.add_argument('-q', action='store_true', default=False, help='quiet')
    parser.add_argument("-h", action="help", help='show this help message and exit')
    args = parser.parse_args()
    return args


def main():
    bin_path = f'{os.path.dirname(bart.__file__)}'
    db_path = f'{os.path.dirname(bin_path)}/db'
    logger = logging.getLogger('root')
    logging.basicConfig(format='%(asctime)s | %(message)s', datefmt="%H:%M:%S")
    logger.setLevel(logging.DEBUG)
    args = parse_args()
    if args.q:
        logger.setLevel(logging.ERROR)
    logger.info(f'this is bart {__version__} by {__author__}')
    logger.info(f'running on {platform} with Python {str(version_info[:3])[1:-1].replace(", ", ".")}')

    if platform == 'linux':
        finch_binary = f'{bin_path}/finch-linux64-v0.3.0'
    elif platform == 'darwin':
        finch_binary = f'{bin_path}/finch-mac64-v0.3.0'
    else:
        exit(logger.error(f'finch binary not compatible with {platform}'))

    ### Check input filetypes and create read-pair dict ###
    threads = str(args.t)
    if args.t > os.cpu_count():
        logger.warning(f'number of threads exceeds available CPUs')
        threads = str(os.cpu_count())
    logger.info(f'using {threads} threads')

    suffixes = ['_R[12]\.(fastq(?:\.gz)?)$', '_R[12]_[0-9]+?\.(fastq(?:\.gz)?)$',
                '_R[12].[0-9]+?\.(fastq(?:\.gz)?)$', '_[12]\.(fastq(?:\.gz)?)$',
                '_[12]_[0-9]+?\.(fastq(?:\.gz)?)$', '_[12].[0-9]+?\.(fastq(?:\.gz)?)$',
                '_R[12]\.(fq(?:\.gz)?)$', '_R[12]_[0-9]+?\.(fq(?:\.gz)?)$',
                '_R[12].[0-9]+?\.(fq(?:\.gz)?)$', '_[12]\.(fq(?:\.gz)?)$',
                '_[12]_[0-9]+?\.(fq(?:\.gz)?)$', '_[12].[0-9]+?\.(fq(?:\.gz)?)$']

    r = compile('|'.join(suffixes))
    pairs = defaultdict(list)
    for i in args.i:
        if not os.path.isfile(i):
            logger.error(f'{i} is not a valid file')
        else:
            filename = str(i)
            s = search(r, filename)
            if s:
                pairs[filename.replace(s.group(0), '')].append(str(i))
            else:
                logger.error(f'{i} is not a fastq file')

    if not any(os.scandir(f'{db_path}/indexes')):
        logger.info("no indexes found, building from PubMLST")
        os.system("bart-update -p")

        start = time()
    ### Loop over read-pair dict ###
    for name in list(pairs):
        sample = os.path.basename(name)
        logger.info(f'read pair for {sample}: {" ".join(pairs[name])}')

        if args.use_scheme is not None:
            if not args.use_scheme in [f.name.split('.')[0] for f in os.scandir(f'{db_path}/mapping/')]:
                exit(logger.error(f'{args.use_scheme} not a valid scheme, use --schemes to see valid schemes'))
            else:
                scheme = args.use_scheme
        else:
            sketch = f'/tmp/{sample}.sk'
            if not os.path.isfile(sketch):
                finch.sketch_input(finch_binary, pairs[name], sketch)

            finch_out = finch.dist(sketch, db_path, finch_binary)
            logger.info(f'closest refseq genome is {finch_out}')

            d = [f.name.split('.')[0] for f in os.scandir(f'{db_path}/mapping/')]
            # First check genus

            if 'Shigella' in finch_out:
                d = ['Escherichia_coli#1']
                logger.warning('Shigella uses the Escherichia_coli#1 scheme')
            else:
                d = [k for k in d if finch_out.split(' ')[0] in k]

            if len(d) < 1: # More critical if no matching genus, good idea to exit program here and prompt to force scheme
                logger.error(f"no matching schemes for {finch_out.split(' ')[0]}, check available schemes with bart --schemes")

            elif len(d) == 1:
                logger.info(f"genus match for scheme {d[0]}")
                scheme = d[0]

            elif len(d) > 1:  # check species now, if #1/#2 like in Ab, need to account for that
                logger.info(f"{len(d)} matching schemes for genus {finch_out.split(' ')[0]}")
                species, s = set([g.split('_')[1].split('#')[0] for g in d]), []
                for i in species:
                    if SequenceMatcher(None, finch_out.split(' ')[1], i).ratio() == 1:
                        s = [k for k in d if i in k]

                if len(s) < 1:
                    logger.warning(f"no matching schemes for species {finch_out.split(' ')[1]}")
                    # first go with spp, then try genus scheme with most alleles
                    if 'spp' in species:
                        d = [k for k in d if 'spp' in k]
                    else:
                        top_profiles = 0
                        for i in species:
                            with open(f'{db_path}/mapping/{finch_out.split(" ")[0]}_{i}.tab', "r") as f:
                                profiles = len(f.readlines())
                                if profiles > top_profiles:
                                    top_profiles = profiles
                                    d = [f'{finch_out.split(" ")[0]}_{i}']
                    scheme = d[0]
                    logger.warning(f"{d[0]} might cover your species")

                else:
                    logger.info(f"matched species {finch_out.split(' ')[1]} to scheme {s[0]}")
                    scheme = s[0]

        ipe(pairs[name], f'/tmp/{sample}', str(args.percid),
            f'{db_path}/indexes/{scheme}', threads)

        # make a dictionary of kma results where allele is the key
        with open(f'/tmp/{sample}.res', newline='\n') as res:
        #with open(f'/tmp/SRR14197419.res', newline='\n') as res:
            r = res.read().splitlines()
        res_dict = {}
        for line in r[1:]:
            v = line.split('\t')
            v = [x.strip(' ') for x in v]
            k = v[0].rsplit('_', 1)[0]
            v[0] = v[0].rsplit('_', 1)[1]
            if k in list(res_dict):
                if float(v[4]) > float(res_dict[k][4]):
                    res_dict[k] = v
                else:
                    continue
            else:
                res_dict[k] = v

        logger.info(f'{len(res_dict)} hits found')
        if len(res_dict) < 1:
            continue

        # make a dictionary of the scheme where ST is the key
        with open(f'{db_path}/mapping/{scheme}.tab', newline='\n') as tab:
        #with open(f'{db_path}/mapping/Klebsiella_pneumoniae.tab', newline='\n') as tab:
            s = tab.read().splitlines()
        headers, scheme_dict = s[0].split('\t')[1:], {}
        for line in s[1:]: #first column is ST
            v = line.split('\t')
            scheme_dict[int(v[0])] = {headers[i]: v[1:][i] for i in range(len(headers))}

        # make a list of only genes in headers
        genes, exact = [g for g in headers if g not in ['clonal_complex', 'species', 'CC', 'Lineage']], []

        # add info for non-exact matches and make a list of genes with exact matches
        for k in res_dict.keys():
            if float(res_dict[k][4]) < 100:
                res_dict[k][0] += '*'
            if float(res_dict[k][5]) < 100:
                res_dict[k][0] += '?'
            else:
                exact.append(k)

        # quickly filter the scheme profiles based on exact genes
        exact_dict = scheme_dict
        for i in exact:
            for st in list(exact_dict.keys()):
                if exact_dict[st][i] != res_dict[i][0]:
                    exact_dict.pop(st)

        # resort to guessing closest match based on sequence matching
        if len(exact_dict) != 1:
            logger.info(f'no exact profile match, finding closest')
            # make a list of allele numbers for profile sequence match
            y = [v[0] for k, v in res_dict.items() if k in genes]
            scheme_match = defaultdict(list)
            for st in scheme_dict.keys():
                profile = []
                for k, v in scheme_dict[st].items():
                    if k in res_dict.keys() & genes:
                        profile.append(v)
                scheme_match[SequenceMatcher(None, profile, y).ratio()].append(st)

            # Invert the dictionary so match scores are keys and sort by key to take best ST match
            scheme_match = sorted(scheme_match.items(), key=lambda item: item[0], reverse=True)[0]
            if len(scheme_match[1]) > 1:
                logger.info(f'{len(scheme_match[1])} close matches found')
            sts = scheme_match[1]
        else:
            scheme_dict = exact_dict
            sts = scheme_dict.keys()

        # printing output to tab-separated STDOUT for piping
        if args.info:
            x = finch.info(sketch, finch_binary)
            headers += ['genome_size', 'ave_depth', '%GC']

        print('Sample\tScheme\tST\t' + "\t".join([str(x) for x in headers]))
        for st in sts:
            out = sample + '\t' + scheme + '\t' + str(st)
            for k, v in scheme_dict[st].items():
                if k in headers:
                    if v != '':
                        out += '\t' + v
                else:
                    out += '\tno hit'

            if args.info:
                out += '\t{}\t{}\t{}'.format(x[0], x[1], x[2])
            print(out)

            if args.e:
                #with open(f'/tmp/{sample}.res', newline='\n') as fna:
                with open(f'/tmp/SRR14197419.fsa', newline='\n') as fna:
                    seqs = fna.read().split('>')[1:]
                for k, v in res_dict.items():
                    print(res_dict[k][0])

    logger.info(f'completed in {"{:.1f}".format(time() - start)} seconds{bart_ascii()}')


if __name__ == '__main__':
    main()
