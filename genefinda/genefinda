#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from re import search
from collections import defaultdict
from difflib import get_close_matches
from argparse import ArgumentParser
import os
from pathlib import Path
from time import time
from datetime import datetime
from logging import getLogger
from json import loads
from subprocess import Popen, PIPE
from requests import get


def parse_args():
    parser = ArgumentParser(add_help=False, usage="genefinda reads_1.fq.gz reads_2.fq.gz [options]")
    parser.add_argument('input', nargs='+', type=Path, help='Paired-end fastq(.gz)')
    parser.add_argument('-t', type=int, default='4', help='threads')
    parser.add_argument("-h", action="help", help='show this help message and exit')
    args = parser.parse_args()
    return args


def url_dict(): # creates a dict for PubMLST Schemes
    d = defaultdict(list)
    fungi = ["afumigatus", "blastocystis", "calbicans", "cglabrata", "ckrusei",
             "ctropicalis", "csinensis", "kseptempunctata", "sparasitica", "tvaginalis"]
    ft = ['fasta', 'csv']
    for line in get('https://pubmlst.org/static/data/dbases.xml').text.split('\n'):
        if search('<url>', line) and not any(f in line for f in fungi) \
                and any(t in line for t in ft):
            key = line.split('pubmlst_')[1].split('_seqdef')[0]
            d[key].append(line.split('>')[1].split('<')[0])
    return d


def get_ref(path):
    logger = getLogger('\x1b[6;30;42m' + 'Fetch RefSeq Sketches' + '\x1b[0m')
    url = 'https://static.onecodex.com/public/finch-rs/refseq_sketches_21_1000.sk.gz'
    # need to gunzip
    with open(path, 'wb') as out:
        logger.info(f'Downloading {url}')
        out.write(get(url).content)
        logger.info(f'Written to {path}')
    return path

def sketch_input(reads, sketch):
    logger = getLogger('\x1b[6;30;42m' + 'finch' + '\x1b[0m')
    finch = '/home/tom/.cargo/bin/finch'
    cmd = [finch, 'sketch', '-o', sketch, '-']
    logger.info(f'Running: {" ".join(cmd)}')
    child = Popen(cmd, stdin=PIPE)
    child.stdin.write(reads.encode())
    return child.communicate()

def info(sketch):
    logger = getLogger('\x1b[6;30;42m' + 'finch' + '\x1b[0m')
    finch = '/home/tom/.cargo/bin/finch'
    cmd = [finch, 'info', sketch]
    logger.info(f'Running: {" ".join(cmd)}')
    child = Popen(cmd, stdout=PIPE)
    r = child.communicate()[0].decode('utf-8').split('\n')
    return [r.slice(1,3,1).split(': ')] #uniq_kmers, ave_depth, gc%

def dist(sketch, ref):
    logger = getLogger('\x1b[6;30;42m' + 'finch' + '\x1b[0m')
    finch = '/home/tom/.cargo/bin/finch'
    cmd = [finch, 'dist', sketch, ref]
    logger.info(f'Running: {" ".join(cmd)}')
    child = Popen(cmd, stdout=PIPE)
    r = loads(child.communicate()[0])
    return sorted(r, key=lambda k: k['mashDistance'])[0]

def index(infile, outfile):
    logger = getLogger('\x1b[6;30;42m' + 'kma' + '\x1b[0m')
    cmd = ['kma', 'index', '-i', '--', '-o', outfile]
    logger.info(f'Running: {" ".join(cmd)}')
    child = Popen(cmd, stdin=PIPE)
    child.stdin.write(infile.encode())
    return child.communicate()

def ipe(reads, id, index, threads):
    logger = getLogger('\x1b[6;30;42m' + 'kma' + '\x1b[0m')
    cmd = ['kma', '-ipe', reads, '-ID', id,
           '-o', '/dev/stdout', '-t_db', index, '-t', threads]
    # -na -nf -bc90 -mct 0
    logger.info(f'Running: {" ".join(cmd)}')
    child = Popen(cmd, stdout=PIPE)
    return child.communicate()[0].decode()

def build_kma_indexes(d): # builds kma index for each scheme in dictionary
    for k, v in d().items():
        i = ''
        for url in v:
            if 'fasta' in url:
                i += get(url).text
        index(i, f'db/{k}')

def choose_scheme(finch_out): # chooses best scheme based on finch containment
    d = {}
    with open('db/scheme_species_map.tab') as f:
        for line in f:
            key = line.split('\t')[1] + ' ' + line.split('\t')[2]
            d[key.strip()] = line.strip().split('\t')[0]
    return get_close_matches(finch_out, list(d))[0]

def main():
    start = time()
    logger = getLogger('\x1b[6;30;42m' + 'genefinda' + '\x1b[0m')
    logger.info(f'\033[4m{__file__} {__version__}\033[0m')
    logger.info(f'Your system is {os.uname()[0]}')
    if 'Linux' not in os.uname()[0]:
        logger.warning(f'genefinda has not been tested on {os.uname()[0]}')
    logger.info(f'{datetime.today().strftime("%Y-%m-%d-%H:%M:%S")}')

    args = parse_args()
    ### Sanity Checks ###
    if args.t > os.cpu_count():
        logger.warning(f'Number of threads exceeds available CPUs, will use: {os.cpu_count()}')
        threads = str(os.cpu_count())
    else:
        threads = str(args.t)
        logger.info(f'Using {threads} threads...')

    if not os.path.isfile('db/refseq_sketches_21_1000.sk'):
        logger.warning('refseq_sketches_21_1000.sk not found')
        get_ref('db/refseq_sketches_21_1000.sk')

    names = []
    for i in args.input:
        if not os.path.isfile(i):
            logger.error(f'{i} is not a valid file')
            exit()
        else: names.append(os.path.splitext(os.path.basename(str(i)))[0])

    logger.info(f'Input files: {args.input}')
    sample = set(names)
    logger.info(f'Sample name: {sample}')

    sketch_input(args.input)

    logger.info('completed in ' + str(float(time() - start) / 60) + ' mins.')

if __name__ == '__main__':
    main()